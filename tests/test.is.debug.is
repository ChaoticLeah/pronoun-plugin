:: Cache {
    
    //Delete any excess old keys
    @shrink_to_max_keys(obj, max_keys) {
        let new_obj = {}
        let keys = Obj:keys(obj)
        let keys_to_remove = keys.len - max_keys

        for let i, keys.len {
            let k = keys[i]
            if i > keys_to_remove {
                Obj:set(new_obj, k, obj[k])
            }
        }

        return new_obj
    }

    @has(key) {
        return has_manual(key, "cache")
    }

    @has_manual(key, storage_key) {
        var cache = Mk:load(storage_key)

        if cache == null {
            cache = {}
        } else {
            cache = Json:parse(cache)
        }

        return Obj:has(cache, key)
    }

    @clear() {
        return clear_manual("cache")
    }

    @clear_manual(storage_key) {
        Mk:remove(storage_key)
    }

    @remove_manual(key, storage_key) {
        var cache = Mk:load(storage_key)

        if cache == null {
            return null
        } else {
            cache = Json:parse(cache)
        }

        if Obj:has(cache, key) {
            var new_cache = {}
            let keys = Obj:keys(cache)

            for let i, keys.len {
                let k = keys[i]
                if k != key {
                    Obj:set(new_cache, k, cache[k])
                }
            }

            Mk:save(storage_key, Json:stringify(new_cache))
        }
    }

    @remove(key) {
        return remove_manual(key, "cache")
    }

    @save_cache(key, value) {
        return save_cache_manual(key, value, Plugin:config.max_cached_accounts, "cache")
    }

    @save_cache_manual(key, value, max_cached_values, storage_key) {
        var cache = Mk:load(storage_key)

        if cache == null {
            cache = {}
        } else {
            cache = Json:parse(cache)
        }

        Obj:set(cache, key, {
            time: Date:now(),
            value: value,
        })

        if Obj:keys(cache).len > max_cached_values && Obj:keys(cache).len > 0 {
            cache = shrink_to_max_keys(cache, max_cached_values)
        }

        Mk:save(storage_key, Json:stringify(cache))
    }

    @get_cache(key) {
        return get_cache_manual(key, "cache")
    }

    @get_cache_manual(key, storage_key) {
        var cache = Mk:load(storage_key)

        if cache == null {
            cache = {}
        } else {
            cache = Json:parse(cache)
        }

        if Obj:has(cache, key) {
            var data = Obj:get(cache, key)

            //Cache for a day
            if Date:now() - data.time < 1000 * Plugin:config.cache_time || storage_key == "manual_cache" {
                return data.value
            } else {
                return null
            }
        } else {
            return null
        }
    }
}

:: Updater {
    @check_for_update(update_message_title, update_message, update_icon, versionPost, current_version){
        let post = API:get_post_by_url(versionPost)    
        if post != null {
            let text = post.object.text
            if Json:parsable(text) {
                let latest_version = Json:parse(post.object.text).pronounPluginVersion
                if latest_version > current_version && Mk:load("updateRequested") != latest_version {
                    API:send_notification(update_message, update_message_title, update_icon)
                    Mk:save("updateRequested", latest_version)
                }
            }
        }
    }
}


:: API {
    //write:notifications
    @send_notification(message, header, icon){
        Mk:api("notifications/create", {
            body: message, 
            header: header,
            icon: icon
        }) 
    }
    //read:account
    @get_post_by_url(posturl){
        let post = Mk:api("ap/show", {
            uri: posturl
        })
        
        if Obj:has(post, "type") {
            return post
        }
        return null
    }
}




:: PluralTools {
	@is_post_plural(post) {
		post.incl("$[scale.hm") || post.incl("<small> - posted by ")
	}

	@get_headmates(post) {
		let filtered_post = post.split("$[scale.hm ")
		let headmates = []
		if filtered_post.len > 1 {
        	filtered_post.shift()
			for let i, filtered_post.len {
            	let headmate_name = filtered_post[i].split(']')[0].trim()
				headmates.push(headmate_name)
			}
		}

        if post.incl("<small> - posted by ") {
            headmates.push(post.split("<small> - posted by ")[1].split("</small>")[0].split(Str:lf)[0])
        }

        return headmates
	}

    @get_pronouns_from_cache(headmates, username, host, description) {
        for let i, headmates.len {
            if !Cache:has([username, "#", headmates[i], "@", host].join()) {
                return PronounTools:get_headmates_kv(headmates, description)
            }
        }

        //Now we know we have all the headmates needed
        let kv = {}
        for let i, headmates.len {
            let key = [username, "#", headmates[i], "@", host].join()

            if Cache:has_manual(key, "manual_cache") {
                Obj:set(kv, headmates[i], Cache:get_cache_manual(key, "manual_cache"))
            } else {
                Obj:set(kv, headmates[i], Cache:get_cache(key))
            }
        }
        return kv
        
    }

}


:: PronounTools {

    // Some people include pronouns in their username.
    @already_contains_pronouns(name) {
        return PronounTools:find_pronouns_in_desc(name) != ""
    }

    
    @style_pronouns(name, pronouns) {
        var pnouns = pronouns
        let ltr_char = Str:from_codepoint(8237)

        if pnouns == null || pnouns.trim() == "" {
            if Plugin:config.debug {
                pnouns = "Unknown"
            } else {
                return name
            }
        }
                
        return Plugin:config.pronoun_template.replace("%[name]", [name, ltr_char].join()).replace("%[pronouns]", [ltr_char, pnouns].join())
    }

    // Remove any pronouns that were added by style_pronouns using the configured template.
    // This attempts to reverse the template by replacing the %[name] and %[pronouns] parts
    @remove_added_pronouns(name_with_pronouns) {
        if name_with_pronouns == null {
            return name_with_pronouns
        }

        let ltr_char = Str:from_codepoint(8237)
        // Build the exact string that style_pronouns would produce for a given name
        // but with a placeholder for pronouns. We'll locate the LTR marker plus the pronoun area
        // and strip it.
        let name_marker = Plugin:config.pronoun_template.replace("%[name]", "__NAME__").replace("%[pronouns]", "__PRON__")

        // If the template doesn't include the markers as expected, fallback to a simple removal
        if !name_marker.incl("__NAME__") || !name_marker.incl("__PRON__") {
            // Fallback: remove any occurrence of the LTR char and anything after the last space/paren
            if name_with_pronouns.incl(ltr_char) {
                return name_with_pronouns.split(ltr_char)[0].trim()
            }
            return name_with_pronouns
        }

        // The template places an LTR char after the name and before pronouns when style_pronouns is used.
        // So find that LTR char and strip it and everything after it.
        if name_with_pronouns.incl(ltr_char) {
            return name_with_pronouns.split(ltr_char)[0].trim()
        }

        return name_with_pronouns
    }

    @check_pronoun_length(word) {
        var slash_count = word.to_unicode_arr().filter(@(v) {
            return v == "/"
        }).len

        return slash_count * 10 > word.len
    }

    @find_pronouns_in_desc(desc) {
        let words_in_desc = split_by_space_and_nl(desc)
        //desc.split(" ")
        if Plugin:config.debugExperimentalDescMethod {
            print(words_in_desc)
        }

        for let i, words_in_desc.len {

            let word = trim_parrens(trim_mfm(words_in_desc[i])).replace(",", "")
            //Make sure there is a / and its not w/ (Cuz thats short for with)
            let is_potential_pronoun = check_pronoun_length(word) && word.incl("/") && (!word.incl(" w/")) && (!word.incl("and/or")) && (!word.incl("or/and")) && (!word.incl(".")) && (!word.incl("http")) && (word.index_of("/") > 1 || word.len == 1)

            if is_potential_pronoun {
                let is_fraction = is_word_fraction(word)
                let is_word_mfm = is_word_mfm(word)
                if (!is_fraction) && (!is_word_mfm) {
                    // That might mean someone spaced it out like she / her vs she/her
                    if (word.len == 1 && i != 0 && i != words_in_desc.len) {
                        return [trim_mfm(words_in_desc[i - 1]), word, trim_mfm(words_in_desc[i + 1])].join("").replace(",", "").replace("\"", "")
                    }

                    return word.trim().replace("\"", "")
                }
            }
            
        }
        return ""
    }

    @find_pronouns_in_fields(fields) {
        // If we can find a field that is "pronouns" prefer that
        for let i, fields.len {
            let name = fields[i].name.lower()
            let value = fields[i].value.lower()
            
            if (name.incl("pronoun") && !value.incl("depends")) {
                // For some reason it wasnt working when added to the end of the last if statement but works here???
                if !value.incl("http") {
                    return value
                }
            }
        }
        // Otherwise fallback to searching
        for let i, fields.len {
            let found_pronouns_value = PronounTools:find_pronouns_in_desc(fields[i].value)
            
            if found_pronouns_value != "" && !found_pronouns_value.incl("http") {
                return found_pronouns_value
            }

            //Cuz some people put pronouns in the name of the field.... (turned off cuz its so uncommon and leads to false positives)
            // let found_pronouns_name = PronounTools:find_pronouns_in_desc(fields[i].name)

            // if found_pronouns_name != "" && !found_pronouns_name.incl("http") {
            //     return found_pronouns_name
            // }
        }
        return null
    }

    @get_desc_starting_from(desc, name) {
        let descHeadmateMentionStart = desc.index_of(name) 
        return desc.slice(descHeadmateMentionStart, desc.len)
    }

    @find_headmate_pronouns_in_desc(headmate, desc) {
        return PronounTools:find_pronouns_in_desc(PronounTools:get_desc_starting_from(desc, headmate))
    }

    @get_headmates_kv(headmates, desc) {
        let kv = {}
        for let i, headmates.len {
            Obj:set(kv, headmates[i], PronounTools:find_headmate_pronouns_in_desc(headmates[i], desc))
        }
        return kv
    }

    @get_pronouns_from_desc(description) {
        if Plugin:config.experimentalDescMethod {
            return PronounTools:find_pronouns_in_desc(description)
        } else {
            return PronounTools:check_desc(description)
        }
    }

    @insert_headmate_pronouns(post, kv) {
        var keys = Obj:keys(kv)
        for let i, keys.len {
            var key = keys[i]
            var value = kv[key]

            if !PronounTools:already_contains_pronouns(key) {
                post = post.replace(["$[scale.hm ", key, "]"].join(), ["$[scale.hm ", PronounTools:style_pronouns(key, value), "]"].join())
                post = post.replace(["<small> - posted by ", key].join(), ["<small> - posted by ", PronounTools:style_pronouns(key, value)].join())
            }

        }
        return post
    }

    //Checking for pronoun/ or /pronoun in a description
    //For example she/ or /her
    //Used in the old method for finding pronouns
    @is_pronoun(pronoun, lowerDesc){
        return lowerDesc.index_of([pronoun, "/"].join()) != -1 || lowerDesc.index_of(["/", pronoun].join()) != -1
    }
}

@contains_any(arr, str){
    for let i, arr.len {
        let found_pronoun = str.incl(arr[i])
        if found_pronoun {
            return true
        }
    }
    return false
}


@is_word_fraction(word){
    return contains_any(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], word)
}

@is_word_mfm(word){
    return contains_any(["<", ">"], word)
}

@trim_mfm(word){
    var trimmed = word.split("]")[0].split("[")
    return trimmed[trimmed.len - 1]
}

@trim_parrens(word){
    var trimmed = word.split(")")[0].split("(")
    return trimmed[trimmed.len - 1]
}

@split_by_space_and_nl(desc) {
    var arr = desc.split(" ")
    var new_arr = []
    for let i, arr.len {
        let split_by_nl = arr[i].split(Str:lf)
        for let j, split_by_nl.len {
            new_arr.push(split_by_nl[j])
        }
    }

    return new_arr
}

@replace_last(str, key, replacer) {
    let split_by_key = str.split(key)
    split_by_key.pop()
    let start_of_word_to_replace = split_by_key.join(key).len
    let end_of_word_to_replace = start_of_word_to_replace + key.len
    return [str.slice(0, start_of_word_to_replace), replacer, str.slice(end_of_word_to_replace , str.len) ].join("")
}



Test:expect("split_by_space_and_nl", split_by_space_and_nl("Hello
world what a
wonderful day")).toEqual(["Hello", "world", "what", "a", "wonderful", "day"])

Test:expect("trim_parrens", trim_parrens("(She/Her)")).toEqual("She/Her")

Test:expect("trim_mfm", trim_mfm("$[scale.x=10 Hello]")).toEqual("Hello")

Test:expect("is_word_fraction", is_word_fraction("10/21")).toEqual(true)

Test:expect("is_word_fraction", is_word_fraction("She/Her")).toEqual(false)

Test:expect("contains_any - true", contains_any(["they", "she"], "she/her")).toEqual(true)

Test:expect("contains_any - false", contains_any(["him", "she"], "they/them")).toEqual(false)




:: Plugin {
    let config = {
        debugExperimentalDescMethod: false,
        pronoun_template: "%[name] (%[pronouns])",
        // experimentalDescMethod: true,
        checkFields: true,
        cache_time: 86400,
        debugExperimentalDescMethod: false,
        debug: false
    }
}


Test:expect("Check if post contains plural - MFM", PluralTools:is_post_plural("Hello World
$[scale.x=2,y=2 I love plural plugin]")).toEqual(false)

Test:expect("Check if post contains plural - MFM", PluralTools:is_post_plural("Hello World
Posted by $[scale.hm Leah]")).toEqual(true)

Test:expect("Check if post contains plural - Legacy", PluralTools:is_post_plural("Hello
<small> - posted by Leah</small>")).toEqual(true)



Test:expect("Check if headmates are detected in post", PluralTools:get_headmates("Hello World
Posted by $[scale.hm Leah]")).toEqual(["Leah"])

Test:expect("Check if headmates are detected in post", PluralTools:get_headmates("Hello World. $[scale.hm Nate] is so cool!
Posted by $[scale.hm Leah] and $[scale.hm Emma]")).toEqual(["Nate", "Leah", "Emma"])

Test:expect("Check if headmates are detected in post - Legacy", PluralTools:get_headmates("Hello World. $[scale.hm Nate] is so cool!

<small> - posted by Leah</small>")).toEqual(["Nate", "Leah"])


Test:expect("find_pronouns_in_fields - easy", PronounTools:find_pronouns_in_fields([{
    name: "Age",
    value: "21"
},{
    name: "My website",
    value: "https://woem.men/"
},
{
    name: "pronouns",
    value: "she/her"
}])).toEqual("she/her")

Test:expect("find_pronouns_in_fields - complex", PronounTools:find_pronouns_in_fields([{
    name: "Age",
    value: "21"
},{
    name: "My website",
    value: "https://woem.men/"
},
{
    name: "nouns pro(tm)",
    value: "fae/faer"
}])).toEqual("fae/faer")


//The short ones are basically used for field detection
Test:expect("Can grab pronouns description - Short", PronounTools:find_pronouns_in_desc("She/Her")).toEqual("She/Her")

Test:expect("Can grab pronouns description - Short", PronounTools:find_pronouns_in_desc("[She/Her]")).toEqual("She/Her")

Test:expect("Can grab pronouns description - Short", PronounTools:find_pronouns_in_desc("https://woem.men/my/notifications")).toEqual("")

Test:expect("Can grab pronouns description - Short", PronounTools:find_pronouns_in_desc("@john@mastodon.social")).toEqual("")

Test:expect("Can grab pronouns description - Basic", PronounTools:find_pronouns_in_desc(
"
Amazing 10/10!
https://woem.men/
Having fun w/aiscript

$[position.x=28,y=1.8 $[scale.x=0.6,y=0.6 ðŸŸ¢   ðŸŸ¡   ðŸ”´]]
$[border.color=111111,radius=6,width=27 $[bg.color=111111 $[font.monospace $[fg.color=00ff00 <plain>root@leah:~# cat gender_and_sexuality.json

{
	pronouns: She/Her
}

root@leah:~# cat bio.txt

I draw, code, and make videos. I'm fun sized! :ChikaPout:
$[fg.color=F5A9B8 Artist], $[fg.color=5BCEFF Programmer], $[fg.color=F5A9B8 And more]

Poly and ADHD creature

<small>Also the reason @ashten changed backups to hourly :gura_cool:</small>


root@leah:~# :block_terminal_cursor:
]]
")).toEqual("She/Her")

Test:expect("Can grab pronouns description - Basic - No Pronouns", PronounTools:find_pronouns_in_desc(
"
Amazing 10/10!
https://woem.men/
Having fun w/aiscript

meow
")).toEqual("")




var headmateDesc = 
"
Hi we are a bunch of queer folks here to bring a smile to all your faces on fedi!

Meet the system!

Leah
 - Meow! She/Her

Emma:
 - Super duper gay! fae/faer

Nate:
 - Catboy, he/him


test:
meow/meow
"


Test:expect("Can grab pronouns description - Headmate - Leah", PronounTools:find_headmate_pronouns_in_desc("Leah", headmateDesc)).toEqual("She/Her")

Test:expect("Can grab pronouns description - Headmate - Emma", PronounTools:find_headmate_pronouns_in_desc("Emma", headmateDesc)).toEqual("fae/faer")

Test:expect("Can grab pronouns description - Headmate - Nate", PronounTools:find_headmate_pronouns_in_desc("Nate", headmateDesc)).toEqual("he/him")

Test:expect("Can grab pronouns description - Headmate - test", PronounTools:find_headmate_pronouns_in_desc("test", "test:
meow/meow")).toEqual("meow/meow")


Test:expect("Check if already contains pronouns - Leah", PronounTools:already_contains_pronouns("Leah :neocat_blush_hide: :v_trans: (She/Her)")).toEqual(true)

Test:expect("Check if already contains pronouns - Luna", PronounTools:already_contains_pronouns("Luna (Fae/Faer)")).toEqual(true)


var post = 
"
Hello World. $[scale.hm Nate] is so cool!

<small> - posted by Leah</small>
"

var final_post = 
"
Hello World. $[scale.hm Nateâ€­ (â€­he/him)] is so cool!

<small> - posted by Leahâ€­ (â€­She/Her)</small>
"

var kv = PronounTools:get_headmates_kv(PluralTools:get_headmates(post), headmateDesc)

Test:expect("Get headmate pronouns from desc and store in key/value", kv).toEqual({ Nate: "he/him",Leah: "She/Her" })

Test:expect("Append all headmates pronouns", PronounTools:insert_headmate_pronouns(post, kv)).toEqual(final_post)



 post = 
"Meow :neocat_floof_sad:

<small> - posted by Nate
 ?[Plural Plugin](https://woem.men/@ChaosKitsune/pages/1711151651951)</small>"

 final_post = 
"Meow :neocat_floof_sad:

<small> - posted by Nateâ€­ (â€­he/him)
 ?[Plural Plugin](https://woem.men/@ChaosKitsune/pages/1711151651951)</small>"

 kv = PronounTools:get_headmates_kv(PluralTools:get_headmates(post), headmateDesc)

Test:expect("Get headmate pronouns from desc and store in key/value", kv).toEqual({ Nate: "he/him",Leah: "She/Her" })

Test:expect("Append all headmates pronouns", PronounTools:insert_headmate_pronouns(post, kv)).toEqual(final_post)

 post = "
Ignore this

 - $[scale.hm leah]

$[scale.hm meow] 
hello hello
$[scale.hm test]"

 kv = PronounTools:get_headmates_kv(PluralTools:get_headmates(post), headmateDesc)




Test:expect("Style Pronouns", PronounTools:style_pronouns("Leah", "She/Her")).toEqual("Leahâ€­ (â€­She/Her)")

Test:expect("Style Pronouns - Reverse", PronounTools:style_pronouns("â€® haeL", "She/Her")).toEqual("â€® haeLâ€­ (â€­She/Her)")


var real_world_plural_desc = "<center> $[fg.color=7F7F7E m]$[fg.color=A0A0A0 e]$[fg.color=C4C4C4 o]$[fg.color=E1B9C6 o]$[fg.color=FDADC8 o]$[fg.color=FFD6E3 o]$[fg.color=FFFFFF w]$[fg.color=FFD6E3 w]$[fg.color=FDADC8 w]$[fg.color=E1B9C6 w] $[fg.color=A0A0A0 :]$[fg.color=7F7F7E 3] & $[fg.color=00ff67 beep!] We're a system of two eepy #trans :neocat_flag_polyam: #demigirl :neocat_flag_demigirl: princesses who love to sail the high seas :blobcatpirate:, lossless music :menhera_music: and :hot_wheels_trans: **System:** - Ori (she/her), Catgirl, Host - [jade](https://dash.pluralkit.me/profile/m/tpffcn) (it/it's), Robotcreature, probaly holds about 10y of trauma Also Ori is a lil manga addict so feel free to provide us with recommendations <3 Sometimes Ori DJ's but lately she kinda gave up on it cuz of missing motivation :( :neocat_flag_lesbian_kisser: :nix_lesbian: :steam_deck: :lineage: :rosahaj_hyper_comfy: Oh and we're obsessed with these (we have 7): $[x4 :emotional_support_demon:] **What other creatures think:** @fennie@oomfie.city: _Ori doesn_'_t eep_, _spinnies all night long_ @kuki@layer8.space: _Free range and bio_ @dia2Why@layer8.space: _My Linux addicted kitty cat_ @xyla@shitpost.trade: _damn_, @freya@chaosfem.tw: _your emptyheadedness is obvious_ (_and cute_) </center>"

var real_world_plural_post = "Spinny, shiny discs cool...... :neobot_aww:

One can just buy funny lookin plastic cases and get the most random music ever for a few bucks

<small> - posted by [jade](https://dash.pluralkit.me/profile/m/tpffcn)â€­ (â€­she/her)</small>"

//Expect it/it's
Test:expect("Real world plural post (Jade)", PronounTools:find_headmate_pronouns_in_desc("jade", real_world_plural_desc)).toEqual("it/it's")


// PronounTools


let a = "meow meow

<small> - posted by testâ€­ (â€­it/she)</small>"

Test:expect("Remove added pronouns", PronounTools:remove_added_pronouns(a)).toEqual("meow meow

<small> - posted by test")











//Todo make this function also detect headmates in the old system


// Test:expect("2 is 2", 22).toEqual(2)

// Test:describe(@() {
//     // Test:it("meow meow", @() {

//     //     Test:expect(1 + 1):toEqual(2)    
//     // })
//     // Test:it("meow meow", @() {

//     //     Test:expect(PluralTools:is_post_plural("")):toEqual(2)    
//     // })   
    
// })
