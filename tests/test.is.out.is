:: Cache {
    @remove_key(key) {
        var cache = Mk:load("cache")

        if cache == null {
            cache = {}
        } else {
            cache = Json:parse(cache)
        }

        let new_obj = {}

        for let i, Obj:keys(cache).len {
            let key = Obj:keys(cache)[i]

            Obj:set(new_obj, key, cache[key])
        }

        Mk:save("cache", Json:stringify(new_obj))
    }

    @has(key) {
        var cache = Mk:load("cache")

        if cache == null {
            cache = {}
        } else {
            cache = Json:parse(cache)
        }

        return Obj:has(cache, key)
    }

    @clear() {
        Mk:remove("cache")
    }

    @save_cache(key, value) {
        var cache = Mk:load("cache")

        if cache == null {
            cache = {}
        } else {
            cache = Json:parse(cache)
        }

        Obj:set(cache, key, {
            time: Date:now(),
            value: value,
        })

        Mk:save("cache", Json:stringify(cache))
    }

    @get_cache(key) {
        var cache = Mk:load("cache")

        if cache == null {
            cache = {}
        } else {
            cache = Json:parse(cache)
        }

        if Obj:has(cache, key) {
            var data = Obj:get(cache, key)

            //Cache for a day
            if Date:now() - data.time < 1000 * Plugin:config.cache_time {
                return data.value
            } else {
                return null
            }
        } else {
            return null
        }
    }
}

:: Updater {
    @check_for_update(update_message_title, update_message, update_icon, versionPost, current_version){
        let post = API:get_post_by_url(versionPost)    
        if post != null {
            let text = post.object.text
            if Json:parsable(text) {
                let latest_version = Json:parse(post.object.text).pronounPluginVersion
                if latest_version > current_version && Mk:load("updateRequested") != latest_version {
                    API:send_notification(update_message, update_message_title, update_icon)
                    Mk:save("updateRequested", latest_version)
                }
            }
        }
    }
}


:: API {
    //write:notifications
    @send_notification(message, header, icon){
        Mk:api("notifications/create", {
            body: message, 
            header: header,
            icon: icon
        }) 
    }
    //read:account
    @get_post_by_url(posturl){
        let post = Mk:api("ap/show", {
            uri: posturl
        })
        
        if Obj:has(post, "type") {
            return post
        }
        return null
    }
}




:: PluralTools {
	@is_post_plural(post) {
		post.incl("$[scale.hm") || post.incl("<small> - posted by ")
	}

	@get_headmates(post) {
		let filtered_post = post.split("$[scale.hm ")
		let headmates = []
		if filtered_post.len > 1 {
        	filtered_post.shift()
			for let i, filtered_post.len {
            	let headmate_name = filtered_post[i].split(']')[0].trim()
				headmates.push(headmate_name)
			}
		}

        if post.incl("<small> - posted by ") {
            headmates.push(post.split("<small> - posted by ")[1].split("</small>")[0].split(Str:lf)[0])
        }

        return headmates
	}

    @get_pronouns_from_cache(headmates, username, host, description) {
        for let i, headmates.len {
            if !Cache:has([username, "#", headmates[i], "@", host].join()) {
                return PronounTools:get_headmates_kv(headmates, description)
            }
        }

        //Now we know we have all the headmates needed
        let kv = {}
        for let i, headmates.len {
            Obj:set(kv, headmates[i], Cache:get_cache([username, "#", headmates[i], "@", host].join()))
        }
        return kv
        
    }

}


:: PronounTools {

    // Some people include pronouns in their username.
    @already_contains_pronouns(name) {
        return PronounTools:find_pronouns_in_desc(name) != ""
    }

    @reverse_replace_if_ltr(str, key, replacer) {
        let lrt = "‚ÄÆ"
        if str.index_of(lrt) == -1 {
            return str.replace(key, replacer)
        }

        if str.index_of(key) > str.index_of(lrt) {
            return str.replace(key, reverse_str(replacer))
        }
    
    }
    
    @style_pronouns(name, pronouns) {
        var pnouns = pronouns
        // let ltr_char = "‚Ä≠"

        if pnouns == null || pnouns.trim() == "" {
            if Plugin:config.debug {
                pnouns = "Unknown"
            } else {
                return name
            }
        }
        
        return PronounTools:reverse_replace_if_ltr(Plugin:config.pronoun_template.replace("%[name]", name), "%[pronouns]", [pnouns].join())
        
        //name:"‚ÄÆüê∞ innuB :bunHop:"
        // return PronounTools:reverse_replace_if_ltr(PronounTools:reverse_replace_if_ltr(Plugin:config.pronoun_template, "%[name]", name), "%[pronouns]", [ltr_char, pnouns].join())
        // return Plugin:config.pronoun_template.replace("%[name]", name).replace("%[pronouns]", [ltr_char, pnouns].join())
    }

    @find_pronouns_in_desc(desc) {
        let words_in_desc = split_by_space_and_nl(desc)
        //desc.split(" ")
        if Plugin:config.debugExperimentalDescMethod {
            print(words_in_desc)
        }

        for let i, words_in_desc.len {

            let word = trim_parrens(trim_mfm(words_in_desc[i])).replace(",", "")
            //Make sure there is a / and its not w/ (Cuz thats short for with)
            let is_potential_pronoun = word.len < 16 && word.incl("/") && (!word.incl(" w/")) && (!word.incl("and/or")) && (!word.incl("or/and")) && (!word.incl(".")) && (!word.incl("http")) && (word.index_of("/") > 1 || word.len == 1)

            if is_potential_pronoun {
                let is_fraction = is_word_fraction(word)
                let is_word_mfm = is_word_mfm(word)
                if (!is_fraction) && (!is_word_mfm) {
                    // That might mean someone spaced it out like she / her vs she/her
                    if (word.len == 1 && i != 0 && i != words_in_desc.len) {
                        return [trim_mfm(words_in_desc[i - 1]), word, trim_mfm(words_in_desc[i + 1])].join("").replace(",", "").replace("\"", "")
                    }

                    return word.trim().replace("\"", "")
                }
            }
            
        }
        return ""
    }

    @find_pronouns_in_fields(fields) {
        // If we can find a field that is "pronouns" prefer that
        for let i, fields.len {
            let name = fields[i].name.lower()
            let value = fields[i].value.lower()
            
            if (name.incl("pronoun") && !value.incl("depends")) {
                // For some reason it wasnt working when added to the end of the last if statement but works here???
                if !value.incl("http") {
                    return value
                }
            }
        }
        // Otherwise fallback to searching
        for let i, fields.len {
            let found_pronouns_value = PronounTools:find_pronouns_in_desc(fields[i].value)
            
            if found_pronouns_value != "" && !found_pronouns_value.incl("http") {
                return found_pronouns_value
            }

            //Cuz some people put pronouns in the name of the field....
            let found_pronouns_name = PronounTools:find_pronouns_in_desc(fields[i].name)

            if found_pronouns_name != "" && !found_pronouns_name.incl("http") {
                return found_pronouns_name
            }
        }
        return null
    }

    @get_desc_starting_from(desc, name) {
        let descHeadmateMentionStart = desc.index_of(name) 
        return desc.slice(descHeadmateMentionStart, desc.len)
    }

    @find_headmate_pronouns_in_desc(headmate, desc) {
        return PronounTools:find_pronouns_in_desc(PronounTools:get_desc_starting_from(desc, headmate))
    }

    @get_headmates_kv(headmates, desc) {
        let kv = {}
        for let i, headmates.len {
            Obj:set(kv, headmates[i], PronounTools:find_headmate_pronouns_in_desc(headmates[i], desc))
        }
        return kv
    }

    @get_pronouns_from_desc(description) {
        if Plugin:config.experimentalDescMethod {
            return PronounTools:find_pronouns_in_desc(description)
        } else {
            return PronounTools:check_desc(description)
        }
    }

    // When something like $[scale.hm leah] is detected grab the pronouns
    // @replace_headmate_mfm(post, desc) {
    //     let headmates = post.split("$[scale.hm ")
    //     if headmates.len > 1 {
    //         headmates.shift()

    //         for let i, headmates.len {
    //             let headmate_name = headmates[i].split(']')[0].trim()
    //             let current_fronter_desc = get_desc_starting_from(desc, headmate_name)
    //             var descPronoun = get_pronouns_from_desc(current_fronter_desc)

    //             if descPronoun.len == 0  {
    //                 if Plugin:config.debug  {
    //                     descPronoun = "(Unknown)"
    //                 } else {
    //                     descPronoun = ""
    //                 }
    //             } else {
    //                 descPronoun = ["(", descPronoun, ")"].join()
    //             }

    //             post = post.replace(["$[scale.hm ", headmate_name, "]"].join(), [headmate_name, descPronoun].join())
    //         }

    //         return post
    //     } else {
    //         return post
    //     }
    // }

    @insert_headmate_pronouns(post, kv) {
        var keys = Obj:keys(kv)
        for let i, keys.len {
            var key = keys[i]
            var value = kv[key]

            if !PronounTools:already_contains_pronouns(key) {
                post = post.replace(["$[scale.hm ", key, "]"].join(), ["$[scale.hm ", PronounTools:style_pronouns(key, value), "]"].join())
                post = post.replace(["<small> - posted by ", key].join(), ["<small> - posted by ", PronounTools:style_pronouns(key, value)].join())
            }

        }
        return post
    }

    //Checking for pronoun/ or /pronoun in a description
    //For example she/ or /her
    //Used in the old method for finding pronouns
    @is_pronoun(pronoun, lowerDesc){
        return lowerDesc.index_of([pronoun, "/"].join()) != -1 || lowerDesc.index_of(["/", pronoun].join()) != -1
    }
}


@reverse_str(str) {
    let str_bits = str.split('')

    var final_str = ""
    for let i, str.len {
        final_str = [final_str, str_bits[str.len - 1 - i]].join()
    }

    return final_str
}

@contains_any(arr, str){
    for let i, arr.len {
        let found_pronoun = str.incl(arr[i])
        if found_pronoun {
            return true
        }
    }
    return false
}


@is_word_fraction(word){
    return contains_any(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], word)
}

@is_word_mfm(word){
    return contains_any(["<", ">"], word)
}

@trim_mfm(word){
    var trimmed = word.split("]")[0].split("[")
    return trimmed[trimmed.len - 1]
}

@trim_parrens(word){
    var trimmed = word.split(")")[0].split("(")
    return trimmed[trimmed.len - 1]
}

@split_by_space_and_nl(desc) {
    var arr = desc.split(" ")
    var new_arr = []
    for let i, arr.len {
        let split_by_nl = arr[i].split(Str:lf)
        for let j, split_by_nl.len {
            new_arr.push(split_by_nl[j])
        }
    }

    return new_arr
}

@replace_last(str, key, replacer) {
    let split_by_key = str.split(key)
    split_by_key.pop()
    let start_of_word_to_replace = split_by_key.join(key).len
    let end_of_word_to_replace = start_of_word_to_replace + key.len
    return [str.slice(0, start_of_word_to_replace), replacer, str.slice(end_of_word_to_replace , str.len) ].join("")
}



Test:expect("split_by_space_and_nl", split_by_space_and_nl("Hello
world what a
wonderful day")).toEqual(["Hello", "world", "what", "a", "wonderful", "day"])

Test:expect("trim_parrens", trim_parrens("(She/Her)")).toEqual("She/Her")

Test:expect("trim_mfm", trim_mfm("$[scale.x=10 Hello]")).toEqual("Hello")

Test:expect("is_word_fraction", is_word_fraction("10/21")).toEqual(true)

Test:expect("is_word_fraction", is_word_fraction("She/Her")).toEqual(false)

Test:expect("contains_any - true", contains_any(["they", "she"], "she/her")).toEqual(true)

Test:expect("contains_any - false", contains_any(["him", "she"], "they/them")).toEqual(false)

Test:expect("reverse_str", reverse_str("Hello World")).toEqual("dlroW olleH")




:: Plugin {
    let config = {
        debugExperimentalDescMethod: false,
        pronoun_template: "%[name] (%[pronouns])",
        // experimentalDescMethod: true,
        checkFields: true,
        cache_time: 86400,
        debugExperimentalDescMethod: false,
        debug: false
    }
}


Test:expect("Check if post contains plural - MFM", PluralTools:is_post_plural("Hello World
$[scale.x=2,y=2 I love plural plugin]")).toEqual(false)

Test:expect("Check if post contains plural - MFM", PluralTools:is_post_plural("Hello World
Posted by $[scale.hm Leah]")).toEqual(true)

Test:expect("Check if post contains plural - Legacy", PluralTools:is_post_plural("Hello
<small> - posted by Leah</small>")).toEqual(true)



Test:expect("Check if headmates are detected in post", PluralTools:get_headmates("Hello World
Posted by $[scale.hm Leah]")).toEqual(["Leah"])

Test:expect("Check if headmates are detected in post", PluralTools:get_headmates("Hello World. $[scale.hm Nate] is so cool!
Posted by $[scale.hm Leah] and $[scale.hm Emma]")).toEqual(["Nate", "Leah", "Emma"])

Test:expect("Check if headmates are detected in post - Legacy", PluralTools:get_headmates("Hello World. $[scale.hm Nate] is so cool!

<small> - posted by Leah</small>")).toEqual(["Nate", "Leah"])

//The short ones are basically used for field detection
Test:expect("Can grab pronouns description - Short", PronounTools:find_pronouns_in_desc("She/Her")).toEqual("She/Her")

Test:expect("Can grab pronouns description - Short", PronounTools:find_pronouns_in_desc("[She/Her]")).toEqual("She/Her")

Test:expect("Can grab pronouns description - Short", PronounTools:find_pronouns_in_desc("https://woem.men/my/notifications")).toEqual("")

Test:expect("Can grab pronouns description - Short", PronounTools:find_pronouns_in_desc("@john@mastodon.social")).toEqual("")

Test:expect("Can grab pronouns description - Basic", PronounTools:find_pronouns_in_desc(
"
Amazing 10/10!
https://woem.men/
Having fun w/aiscript

$[position.x=28,y=1.8 $[scale.x=0.6,y=0.6 üü¢   üü°   üî¥]]
$[border.color=111111,radius=6,width=27 $[bg.color=111111 $[font.monospace $[fg.color=00ff00 <plain>root@leah:~# cat gender_and_sexuality.json

{
	pronouns: She/Her
}

root@leah:~# cat bio.txt

I draw, code, and make videos. I'm fun sized! :ChikaPout:
$[fg.color=F5A9B8 Artist], $[fg.color=5BCEFF Programmer], $[fg.color=F5A9B8 And more]

Poly and ADHD creature

<small>Also the reason @ashten changed backups to hourly :gura_cool:</small>


root@leah:~# :block_terminal_cursor:
]]
")).toEqual("She/Her")

Test:expect("Can grab pronouns description - Basic - No Pronouns", PronounTools:find_pronouns_in_desc(
"
Amazing 10/10!
https://woem.men/
Having fun w/aiscript

meow
")).toEqual("")




var headmateDesc = 
"
Hi we are a bunch of queer folks here to bring a smile to all your faces on fedi!

Meet the system!

Leah
 - Meow! She/Her

Emma:
 - Super duper gay! fae/faer

Nate:
 - Catboy, he/him


test:
meow/meow
"


Test:expect("Can grab pronouns description - Headmate - Leah", PronounTools:find_headmate_pronouns_in_desc("Leah", headmateDesc)).toEqual("She/Her")

Test:expect("Can grab pronouns description - Headmate - Emma", PronounTools:find_headmate_pronouns_in_desc("Emma", headmateDesc)).toEqual("fae/faer")

Test:expect("Can grab pronouns description - Headmate - Nate", PronounTools:find_headmate_pronouns_in_desc("Nate", headmateDesc)).toEqual("he/him")

Test:expect("Can grab pronouns description - Headmate - test", PronounTools:find_headmate_pronouns_in_desc("test", "test:
meow/meow")).toEqual("meow/meow")


Test:expect("Check if already contains pronouns - Leah", PronounTools:already_contains_pronouns("Leah :neocat_blush_hide: :v_trans: (She/Her)")).toEqual(true)

Test:expect("Check if already contains pronouns - Luna", PronounTools:already_contains_pronouns("Luna (Fae/Faer)")).toEqual(true)


var post = 
"
Hello World. $[scale.hm Nate] is so cool!

<small> - posted by Leah</small>
"

var final_post = 
"
Hello World. $[scale.hm Nate (he/him)] is so cool!

<small> - posted by Leah (She/Her)</small>
"

var kv = PronounTools:get_headmates_kv(PluralTools:get_headmates(post), headmateDesc)

Test:expect("Get headmate pronouns from desc and store in key/value", kv).toEqual({ Nate: "he/him",Leah: "She/Her" })

Test:expect("Append all headmates pronouns", PronounTools:insert_headmate_pronouns(post, kv)).toEqual(final_post)



 post = 
"Meow :neocat_floof_sad:

<small> - posted by Nate
 ?[Plural Plugin](https://woem.men/@ChaosKitsune/pages/1711151651951)</small>"

 final_post = 
"Meow :neocat_floof_sad:

<small> - posted by Nate (he/him)
 ?[Plural Plugin](https://woem.men/@ChaosKitsune/pages/1711151651951)</small>"

 kv = PronounTools:get_headmates_kv(PluralTools:get_headmates(post), headmateDesc)

Test:expect("Get headmate pronouns from desc and store in key/value", kv).toEqual({ Nate: "he/him",Leah: "She/Her" })

Test:expect("Append all headmates pronouns", PronounTools:insert_headmate_pronouns(post, kv)).toEqual(final_post)

 post = "
Ignore this

 - $[scale.hm leah]

$[scale.hm meow] 
hello hello
$[scale.hm test]"

 kv = PronounTools:get_headmates_kv(PluralTools:get_headmates(post), headmateDesc)




Test:expect("Style Pronouns", PronounTools:style_pronouns("Leah", "She/Her")).toEqual("Leah (She/Her)")

Test:expect("Style Pronouns - Reverse", PronounTools:style_pronouns("‚ÄÆ haeL", "She/Her")).toEqual("‚ÄÆ haeL )reH/Her(")





// PronounTools















//Todo make this function also detect headmates in the old system


// Test:expect("2 is 2", 22).toEqual(2)

// Test:describe(@() {
//     // Test:it("meow meow", @() {

//     //     Test:expect(1 + 1):toEqual(2)    
//     // })
//     // Test:it("meow meow", @() {

//     //     Test:expect(PluralTools:is_post_plural("")):toEqual(2)    
//     // })   
    
// })
