/// @ 0.12.4
### {
  name: "Pronouns Plugin V3.4.9 - Beta"
  version: "3.3.9"
  author: "@ChaosKitsune@woem.men"
  description: "This will try to put the users pronouns in their name on any given post"
  permissions: ["read:account", "write:notifications"]
  config: {
		// experimentalDescMethod: {
		// 	type: 'boolean'
		// 	label: 'Use experimental algorithm'
		// 	description: 'This could put some random stuff in their name, but also will allow for more acurate pronouns'
		// 	default: true
		// },
        debugExperimentalDescMethod: {
			type: 'boolean'
			label: 'Debug experimental algorithm'
			description: 'Prints the data related to the setting above'
			default: false
		},
        checkFields: {
			type: 'boolean'
			label: 'Check Fields'
			description: 'If its crashing try disabling this'
			default: true
		},
        notifyForUpdates: {
			type: 'boolean'
			label: 'Notify you when there is an update'
			description: 'Turning this on will attempt to notify you once when there is an update for this plugin'
			default: true
		},

		pronoun_template: {
			type: "string"
			label: "Pronoun template"
			description: 'Template for pronoun usernames. "%[name]" is replaced with the username.  "%[pronouns]" is replaced with the pronouns. '
			default: "%[name] (%[pronouns])"
		},

        cache_time: {
            type: 'number',
            label: 'Cache Expiration Time (seconds)',
            description: 'Set how long pronouns should be cached before refreshing. A higher value reduces external requests.',
            default: 86400
        },

        debug: {
			type: 'boolean'
			label: 'Debug'
			description: 'If it fails to find find pronouns it will put (unknown) at the end of the name'
			default: false
		},
    }
}

let updateIcon = "https://woem.men/files/92af615a-4a8b-4fa0-bc61-25aa5b7f6f54"

let version = 12


let versionPost = "https://woem.men/notes/9t8r1dy4eemc1u2l"



:: Cache {
    @save_cache(key, value) {
        Mk:save(["cache_", key].join(), Json:stringify({
            time: Date:now(),
            value: value,
        }))
    }

    @get_cache(key) {
        let data = Mk:load(["cache_", key].join())

        if data {
            data = Json:parse(data)
            //Cache for a day
            if Date:now() - data.time > 1000 * Plugin:config.cache_time {
                return data.value
            } else {
                return null
            }
        } else {
            return null
        }
    }
}

:: Updater {
    @check_for_update(update_message_title, update_message, update_icon, versionPost, current_version){
        let post = API:get_post_by_url(versionPost)    
        if post != null {
            let text = post.object.text
            if Json:parsable(text) {
                let latest_version = Json:parse(post.object.text).pronounPluginVersion
                if latest_version > current_version && Mk:load("updateRequested") != latest_version {
                    API:send_notification(update_message, update_message_title, update_icon)
                    Mk:save("updateRequested", latest_version)
                }
            }
        }
    }
}


:: API {
    //write:notifications
    @send_notification(message, header, icon){
        Mk:api("notifications/create", {
            body: message, 
            header: header,
            icon: icon
        }) 
    }
    //read:account
    @get_post_by_url(posturl){
        let post = Mk:api("ap/show", {
            uri: posturl
        })
        
        if Obj:has(post, "type") {
            return post
        }
        return null
    }
}




:: PluralTools {
	@is_post_plural(post) {
		post.incl("$[scale.hm") || post.incl("<small> - posted by ")
	}

	@get_headmates(post) {
		let filtered_post = post.split("$[scale.hm ")
		let headmates = []
		if filtered_post.len > 1 {
        	filtered_post.shift()
			for let i, filtered_post.len {
            	let headmate_name = filtered_post[i].split(']')[0].trim()
				headmates.push(headmate_name)
			}
		}

        if post.incl("<small> - posted by ") {
            headmates.push(post.split("<small> - posted by ")[1].split("</small>")[0].split(Str:lf)[0])
        }

        return headmates
	}


}


:: PronounTools {
    @style_pronouns(name, pronouns) {
        let ltr_char = "‭"
        return Plugin:config.pronoun_template.replace("%[name]", name).replace("%[pronouns]", [ltr_char, pronouns].join())
    }


    @find_pronouns_in_desc(desc) {
        let words_in_desc = split_by_space_and_nl(desc)
        //desc.split(" ")
        if Plugin:config.debugExperimentalDescMethod {
            print(words_in_desc)
        }

        for let i, words_in_desc.len {

            let word = trim_parrens(trim_mfm(words_in_desc[i])).replace(",", "")
            //Make sure there is a / and its not w/ (Cuz thats short for with)
            let is_potential_pronoun = word.incl("/") && (!word.incl("w/")) && (!word.incl("and/or")) && (!word.incl("or/and")) && (!word.incl(".")) && (!word.incl("http")) && (word.index_of("/") > 1 || word.len == 1)
            if is_potential_pronoun {
                let is_fraction = is_word_fraction(word)
                let is_word_mfm = is_word_mfm(word)
                if (!is_fraction) && (!is_word_mfm) {
                    // That might mean someone spaced it out like she / her vs she/her
                    if (word.len == 1 && i != 0 && i != words_in_desc.len) {
                        return [trim_mfm(words_in_desc[i - 1]), word, trim_mfm(words_in_desc[i + 1])].join("").replace(",", "").replace("\"", "")
                    }

                    return word.trim().replace("\"", "")
                }
            }
            
        }
        return ""
    }

    @find_pronouns_in_fields(userData) {
        let fields = userData.fields

        // If we can find a field that is "pronouns" prefer that
        for let i, fields.len {
            if fields[i].name.lower().incl("pronoun") && !fields[i].value.incl("depends") {
                return fields[i].value
            }
        }
        // Otherwise fallback to searching
        for let i, fields.len {
            let found_pronouns_value = PronounTools:find_pronouns_in_desc(fields[i].value)
            
            if found_pronouns_value != "" {
                return found_pronouns_value
            }

            //Cuz some people put pronouns in the name of the field....
            let found_pronouns_name = PronounTools:find_pronouns_in_desc(fields[i].name)

            if found_pronouns_name != "" {
                return found_pronouns_name
            }
        }
        return null
    }

    @get_desc_starting_from(desc, name) {
        let descHeadmateMentionStart = desc.index_of(name) 
        return desc.slice(descHeadmateMentionStart, desc.len)
    }

    @find_headmate_pronouns_in_desc(headmate, desc) {
        print(PronounTools:get_desc_starting_from(desc, headmate))
        return PronounTools:find_pronouns_in_desc(PronounTools:get_desc_starting_from(desc, headmate))
    }

    @get_headmates_kv(post, desc) {
        //TODO cache
        let headmates = PluralTools:get_headmates(post)
        let kv = {}
        for let i, headmates.len {
            print([headmates[i], PronounTools:find_headmate_pronouns_in_desc(headmates[i], desc)].join())
            Obj:set(kv, headmates[i], PronounTools:find_headmate_pronouns_in_desc(headmates[i], desc))
        }
        return kv
    }

    @get_pronouns_from_desc(description) {
        if Plugin:config.experimentalDescMethod {
            return PronounTools:find_pronouns_in_desc(description)
        } else {
            return PronounTools:check_desc(description)
        }
    }

    // When something like $[scale.hm leah] is detected grab the pronouns
    // @replace_headmate_mfm(post, desc) {
    //     let headmates = post.split("$[scale.hm ")
    //     if headmates.len > 1 {
    //         headmates.shift()

    //         for let i, headmates.len {
    //             let headmate_name = headmates[i].split(']')[0].trim()
    //             let current_fronter_desc = get_desc_starting_from(desc, headmate_name)
    //             var descPronoun = get_pronouns_from_desc(current_fronter_desc)

    //             if descPronoun.len == 0  {
    //                 if Plugin:config.debug  {
    //                     descPronoun = "(Unknown)"
    //                 } else {
    //                     descPronoun = ""
    //                 }
    //             } else {
    //                 descPronoun = ["(", descPronoun, ")"].join()
    //             }

    //             post = post.replace(["$[scale.hm ", headmate_name, "]"].join(), [headmate_name, descPronoun].join())
    //         }

    //         return post
    //     } else {
    //         return post
    //     }
    // }

    @insert_headmate_pronouns(post, kv) {
        var keys = Obj:keys(kv)
        for let i, keys.len {
            var key = keys[i]
            var value = kv[key]

            post = post.replace(["$[scale.hm ", key, "]"].join(), ["$[scale.hm ", PronounTools:style_pronouns(key, value), "]"].join())
            post = post.replace(["<small> - posted by ", key].join(), ["<small> - posted by ", PronounTools:style_pronouns(key, value)].join())

        }
        return post
    }

    //Checking for pronoun/ or /pronoun in a description
    //For example she/ or /her
    //Used in the old method for finding pronouns
    @is_pronoun(pronoun, lowerDesc){
        return lowerDesc.index_of([pronoun, "/"].join()) != -1 || lowerDesc.index_of(["/", pronoun].join()) != -1
    }
}


@contains_any(arr, str){
    for let i, arr.len {
        let found_pronoun = str.incl(arr[i])
        if found_pronoun {
            return true
        }
    }
    return false
}


@is_word_fraction(word){
    return contains_any(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], word)
}

@is_word_mfm(word){
    return contains_any(["<", ">"], word)
}

@trim_mfm(word){
    var trimmed = word.split("]")[0].split("[")
    return trimmed[trimmed.len - 1]
}

@trim_parrens(word){
    var trimmed = word.split(")")[0].split("(")
    return trimmed[trimmed.len - 1]
}

@split_by_space_and_nl(desc) {
    var arr = desc.split(" ")
    var new_arr = []
    for let i, arr.len {
        let split_by_nl = arr[i].split(Str:lf)
        for let j, split_by_nl.len {
            new_arr.push(split_by_nl[j])
        }
    }

    return new_arr
}

@replace_last(str, key, replacer) {
    let split_by_key = str.split(key)
    split_by_key.pop()
    let start_of_word_to_replace = split_by_key.join(key).len
    let end_of_word_to_replace = start_of_word_to_replace + key.len
    return [str.slice(0, start_of_word_to_replace), replacer, str.slice(end_of_word_to_replace , str.len) ].join("")
}



@check_note(note) {

    if note.reply != null {
        note.reply = check_note(note.reply)
    }

    if note.user.name == null {
        note.user.name = ""
    }

    if note.text == null {
        note.text = ""
    }


	var is_plural_post = PluralTools:is_post_plural(note.text)
	
	if is_plural_post {
        var kv = PronounTools:get_headmates_kv(note.text, note.user.description)
        note.text = PronounTools:insert_headmate_pronouns(note.text, kv)
	} else {
        var description = note.user.description
        var pronouns = null

        if Plugin:config.checkFields {            
            var userData = null

            if note.user.host == null {
                userData = Mk:api("users/show", { username: note.user.username })
            } else {
                userData = Mk:api("users/show", { username: note.user.username, host: note.user.host })
            }

            // let userData = Mk:api("users/show", {username: note.user.username, host: host})

            if description == null {
                description = userData.description
            }

            pronouns = PronounTools:find_pronouns_in_fields(userData)
        }

        if pronouns == null {
            pronouns = PronounTools:find_pronouns_in_desc(description)
        }

        if Plugin:config.debug && pronouns == null {
            pronouns = "Unknown"
        }
        
        if pronouns != null {
            note.user.name = PronounTools:style_pronouns(note.user.name, pronouns)
        }

        

	}


    // note.user.name = "meow"

    // var fields = []
    // var notePostedBy = ""
    // var currentlyFronting = ""
    // var description = if note.user.description != null {
    //     note.user.description
    // } else {
    //     ""
    // }
    

    // let data = {
    //     pronouns: "",
    //     pluralPostPronouns: null,
    // }

    // let hasHeadmate = if note.text != null {
    //     get_has_headmate(note.text)
    // } else {
    //     false
    // }

    // if Plugin:config.checkFields {
    //     let userData = Mk:api("users/show", {username: note.user.username, host: note.user.host})
    //     fields = userData.fields
    //     // Misskey cant grab the description from the note sometimes so if it can it grabs it here
    //     if userData.description != null && !hasHeadmate {
    //         note.user.description = userData.description 
    //         description = note.user.description
    //     }
    // }

    // note.text = replace_headmate_mfm(note.text, note.user.description)
    
    // if hasHeadmate {
    //     currentlyFronting = note.user.name.slice(note.user.name.index_of("(") + 1, note.user.name.index_of(")"))

    //     notePostedBy = headmate_post_name(note.text)
    //     let current_fronter_desc = get_desc_starting_from(note.user.description, currentlyFronting)

    //     description = current_fronter_desc

    //     let note_posted_by_desc = get_desc_starting_from(note.user.description, notePostedBy)

    //     if Plugin:config.experimentalDescMethod {
    //         data.pluralPostPronouns = find_pronouns_in_desc(note_posted_by_desc)
    //     } else {
    //         data.pluralPostPronouns = check_desc(note_posted_by_desc)
    //     }

    //     if Plugin:config.debug {
    //         if data.pluralPostPronouns == null {
    //             data.pluralPostPronouns = "Unknown"
    //         }
    //     }
    // }

    // var descPronoun = get_pronouns_from_desc(description)


    // // If nothing comes up for that headmate then just go with the general search
    // if hasHeadmate {
    //     if data.pluralPostPronouns == null {
    //         description = note.user.description
    //         descPronoun = get_pronouns_from_desc(description)
    //     } else {
    //         note.text = replace_last(note.text, notePostedBy, [notePostedBy, " (", data.pluralPostPronouns, ")"].join(""))
    //     }
    // }

    // data.pronouns = descPronoun
    // // If there are headmates then dont use the fields since right now we dont support them (unless no pronouns are found already in the desc)
    // if fields.len > 0 && ((!hasHeadmate) || descPronoun.len == 0 || descPronoun.len > 15) {
    //     for let i, fields.len {
    //         if fields[i].name.lower().incl("pronoun") && !fields[i].value.incl("depends") {
    //             if !Plugin:config.experimentalDescMethod {
    //                 // Overwite the pronouns found in the desc, and prefer ones set in the fields
    //                 if !fields[i].value.incl("http") {
    //                     data.pronouns = fields[i].value
    //                 }
    //             } else {
    //                 var found_pronouns = find_pronouns_in_desc(fields[i].value)

    //                 if found_pronouns.len != 0 {
    //                     data.pronouns = found_pronouns
    //                     if data.pronouns.len == 0 {
    //                         data.pronouns = find_pronouns_in_desc(fields[i].name)
    //                     }
    //                 }
    //             }

    //             break
    //         }
            
    //         //If using the experimental method also apply it to the fields incase they didnt name it pronoun(s)
    //         if Plugin:config.experimentalDescMethod && data.pronouns.len == 0 {
    //             data.pronouns = find_pronouns_in_desc(fields[i].value)
    //             if data.pronouns.len == 0 {
    //                 data.pronouns = find_pronouns_in_desc(fields[i].name)
    //             }
    //         }
    //     }
    // }

    // if Plugin:config.debug {
    //     if data.pronouns.len == 0 {
    //         data.pronouns = "Unknown"
    //     }
    // }

    // //If there are no pronouns then just return it as-is
    // if data.pronouns.len == 0 {
    //     return note
    // }
    
	// var name = note.user.name
	// if name == "" {
	// 	name = note.user.username
	// }
	// let ltr_char = "‭"

    // note.user.name = [name, ltr_char,  " (", data.pronouns, ")"].join("")

    return note

}

Plugin:register_note_view_interruptor(@(note) {
    note = check_note(note)

    if note.renote != null {
        note.renote = check_note(note.renote)
    }

    return note
})

print("Pronouns In Name Successfully Installed")

if Plugin:config.notifyForUpdates {
    Updater:check_for_update("Pronoun Plugin Update", "Please install the latest version of the plugin here https://github.com/ChaoticLeah/pronoun-plugin", updateIcon, versionPost, version)
}
